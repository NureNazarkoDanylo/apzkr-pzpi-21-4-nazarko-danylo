Міністерство освіти і науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук 

Кафедра програмної інженерії 

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА 
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: «Програмна система для автоматизації роботи пральних машин в громадських пральнях»

	Студент гр. ПЗПІ-21-4

	Керівник роботи

		__________ Назарько Д.О.
		   (підпис)
		__________ доц. Лещинська І.О.
		   (підпис)


Роботу захищено «   »           2024 р.
з оцінкою ___________________________

	Комісія:
		__________ Лещинський В.О.
		   (підпис)
		__________ Лещинська І.О.
		   (підпис)
		__________ Сокорчук І.П.
		   (підпис)


2024
Харківський національний університет радіоелектроніки

Факультет    комп’ютерних наук   Кафедра   програмної інженерії    
Спеціальність 121 – Інженерія програмного забезпечення              
Курс   3   Семестр   6   
Навчальна дисципліна Архітектура програмного забезпечення             

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                    Назарьку Данилу Олександровичу                  
       1. Тема проєкту: «Програмна система автоматизації роботи пральних        машин в громадських пральнях»                                       
2. Термін узгодження завдання з лабораторних робіт « 25 »  березня  2024 р. 
3. Термін здачі завдання з лабораторних робіт « 00 »    місяць     2024 р. 
4. Вихідні дані до проєкту: В програмній системі передбачити: дистанційне управління, генерація звітів, керування обладнанням, автентифікація та безпека, управління даними, збір та обробка даних.                      _
5. Зміст звітів з лабораторних робіт (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, кодування програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки.                                           _
6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма взаємодії, UML діаграму діяльності, UML діаграму компонентів.   _
КАЛЕНДАРНИЙ ПЛАН


№
Назва етапу
Термін виконання
Примітка
1
Функціональна специфікація програмного проєкту
22.02.2024
Виконано
2
Проєктування програмного проєкту
01.03.2024
Виконано
3
Кодування програмного проєкту
01.04.24
Виконано
4
Оформлення пояснювальної записки 
30.05.2024
Виконано
5
Захист курсової роботи
08.06.2024
Виконано


Дата видачі завдання «  25  »     березня     2024 р. 

Керівник
доц.                                          Лещинська І.О.   
						  (підпис)

Завдання прийняв до виконання 
ст.гр. ПЗПІІ-21-4                               Назарько Д.О.___
						  (підпис)
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 1 частина, 70 сторінок, 12 рисунків, 3 таблиці, 8 джерел, 5 додатків.
ПРАЛЬНІ МАШИНИ, ГРОМАДСЬКІ ПРАЛЬНІ, АВТОМАТИЗАЦІЯ, СИСТЕМА УПРАВЛІННЯ, ЗМЕНШЕННЯ ВИТРАТ.
Об'єктом дослідження виступають громадські пральні, тобто заклади, де надаються послуги прання за допомогою автоматичних пральних машин. Розглядаються сучасні проблеми, пов'язані з автоматизацією роботи пральних машин та забезпеченням ефективного керування ними.
Метою курсової роботи є розробка системи, що забезпечує підвищення ефективності роботи пральних машин у громадських пральнях, зокрема автоматизацію процесів керування, моніторингу стану пральних машин та взаємодії з користувачами. Система повинна зберігати дані про стан машин, надавати можливість керування та моніторингу збережених даних, впроваджувати функціонал резервування машин, а також забезпечувати користувачів зручними інтерфейсами для використання пральні.
Основні функції системи:
- система повинна збирати та зберігати інформацію про статус кожної пральної машини (зайнята, вільна, в роботі, потребує обслуговування);
- надання можливості адміністратору пральні дистанційно керувати машинами, запускати та зупиняти їх роботу;
- відображення в реальному часі стану всіх пральних машин у пральні;
- користувачі повинні мати можливість заздалегідь бронювати машини через веб-застосунок або мобільний застосунок;
- надання користувачам можливості оплати послуг, отримання сповіщень про завершення циклу прання та інші корисні функції через інтерфейс.
Методи розробки:
- Серверна частина базується на мові програмування C# та фреймворку ASP.NET [1] для обробки запитів та управління даними. PostgreSQL [5] використовується в якості СУБД для зберігання інформації про машини та користувачів.
- Для клієнтської веб частини використовується бібліотека React [6] та фреймворк Next.Js [2], що забезпечує інтерактивну та зручну взаємодію з користувачами.
- Для клієнтської мобільної частини використовується мова програмування Kolin та фреймворк Jetpack Compose [3], що забезпечує інтерактивну та зручну взаємодію з користувачами. 
- IoT пристрій використовує програмовані контролери на базі одноплатних комп’ютерів Raspberry Pi, розроблені на мові програмування C#, що забезпечує автоматизацію та інтеграцію пральних машин в систему.
У результаті роботи здійснено програмну реалізацію системи автоматизації роботи пральних машин у громадських пральнях. Програмна система складається з веб-застосунку, мобільного застосунку, сервера та IoT пристрою. Система забезпечує ефективне керування пральними машинами, спрощує процес використання послуг пральні для користувачів та підвищує загальну ефективність роботи пральні.
ЗМІСТ


Перелік умовних скорочень	9
Вступ	10
1 Аналіз та концептуальне моделювання предметної області	12
1.1 Бізнес-вимоги	12
1.1.1 Бізнес-можливості	12
1.1.2 Бізнес-цілі та критерії успіху	14
1.1.3 Потреби клієнтів або ринку	14
1.1.4 Бізнес-ризики	15
1.2 Концепція рішення	16
1.2.1 Окреслення концепції	16
1.2.2 Головна функціональність	18
1.2.3 Припущення та залежності	19
1.3 Рамки та обмеження проєкту	20
1.3.1 Рамки первинного випуску	20
1.3.2 Рамки наступних випусків	22
1.3.3 Обмеження та винятки	23
1.4 Бізнес-контекст	25
1.4.1 Профілі зацікавлених сторін	25
1.4.2 Пріоритети проєкту	26
1.4.3 Робоче середовище	27
2 Проєктування програмного проєкту	30
2.1 Проєктування серверної частини проєкту	30
2.1.1 Проєктування діаграм	30
2.1.2 Високорівнева архітектура та технології	30
2.1.3 Специфікація REST	33
2.2 Проєктування IoT частини проєкту	35
2.2.1 Проєктування діаграм	35
2.2.2 Високорівнева архітектура та технології	36
2.3 Проєктування клієнтської частини проєкту	37
2.3.1 Проєктування діаграм	37
2.3.2 Структура та технології	38
2.3.3 Реєстрація та вхід у систему	39
2.3.4 Головний функціонал	39
2.4 Проєктування мобільного застосунку	40
3 Кодування програмного проєкту	41
3.1 Кодування серверної частини проєкту	41
3.1.1 Реалізація сервісу для взаємодії з MQTT брокером	41
3.1.2 Валідація даних, що надходять від користувача	42
3.2 Кодування IoT частини проєкту	43
3.2.1 Потік обробки інформації з датчика	43
Висновки	45
Перелік джерел посилання	46
Додаток А. Діаграми серверної частини	47
А.1 ER-модель даних	47
А.2 Діаграма прецедентів	47
А.3 Діаграма розгортання	48
А.4 Діаграма пакетів	49
Додаток Б. Код серверної частини	50
Б.1 Сервіс взаємодії з MQTT брокером	50
Б.2 Приклад валідації запиту на реєстрацію	54
Додаток В. Діаграми IoT частини	56
В.1 Діаграма прецедентів	56
В.2 Діаграма взаємодії	57
В.3 Діаграма діяльності	58
В.4 Діаграма компонентів	59
Додаток Г. Код IoT частини	60
Г.1 Головна програма обробки запитів MQTT брокера	60
Додаток Д. Діаграми веб частини	67
Д.1 Діаграма прецедентів	67
Д.2 Діаграма компонентів	68
Д.3 Діаграма пакетів	69
Д.4 Діаграма взаємодії	70

ПЕРЕЛІК УМОВНИХ СКОРОЧЕНЬ



ВСТУП


У сучасному світі, де технології швидко розвиваються та впроваджуються в усі сфери життя, інноваційні підходи до автоматизації робочих процесів стають важливим елементом підтримки конкурентоспроможності. Громадські пральні, як важлива частина інфраструктури багатьох громад, також потребують технологічних рішень для підвищення ефективності та якості обслуговування. Однак, власники громадських пралень стикаються з низкою проблем, які обмежують їхню продуктивність та задоволеність клієнтів.
Поточні проблеми в управлінні громадськими пральнями включають нестабільну роботу пральних машин, високі витрати на управління та обслуговування, а також низьку ефективність використання обладнання. Зокрема, часті збої у роботі машин призводять до простоїв, що негативно впливає на задоволеність клієнтів та доходи бізнесу. Крім того, ручне управління процесами прання є трудомістким і спричиняє додаткові витрати на оплату праці.
Наслідки цих проблем для бізнесу власників пралень включають зниження прибутковості, збільшення операційних витрат та втрату клієнтів через недостатню якість послуг. Для користувачів це означає тривале очікування, непередбачуваність термінів виконання замовлень та можливі недоліки у якості прання.
Згідно з дослідженням ринку громадських пралень, близько 30% власників зазначають, що їхні пральні машини часто потребують ремонту, а 25% вказують на труднощі з управлінням замовленнями та контролем якості послуг (Джерело: "Дослідження ринку пралень", 2023). Ці дані підкреслюють необхідність впровадження автоматизованих систем для вирішення зазначених проблем.
Цей програмний продукт націлений на автоматизацію роботи пральних машин в громадських пральнях, що дозволить власникам ефективно керувати їхнім функціонуванням та надавати клієнтам зручні та якісні послуги. Головна ідея полягає у створенні інтелектуальної системи, яка спростить управління пральними машинами, автоматизує процес прийому замовлень та контролю якості прання.
Основною метою розробки цього продукту є полегшення робочих процесів для власників громадських пралень, зменшення людського втручання та підвищення якості обслуговування. Цей програмний засіб дозволить автоматизувати багато рутинних операцій, таких як контроль над запуском та зупинкою пральних машин, моніторинг їхнього стану та відслідковування замовлень, що сприятиме підвищенню ефективності та оптимізації робочих процесів.
Отже, цей програмний продукт має на меті створення інструменту для оптимізації управління громадськими пральнями, що сприятиме підвищенню їхньої продуктивності та конкурентоспроможності на ринку.


1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ
МОДЕЛЮВАННЯПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес-можливості


Аналізуючи аналогічні програмні рішення, такі як "Bundle Connect", "Cleantie" та "CleanCloud", які спеціалізуються на послугах "Laundry Pickup & Delivery", можна відзначити, що наша система відрізнятиметься спрямованістю на внутрішнє використання у пралнях. Вона буде призначена для моніторингу та оптимізації робочих процесів пралень, забезпечуючи повний контроль над усіма аспектами їх функціонування.
Наша система пропонує унікальні можливості, яких бракує в конкурентних продуктах:
- Bundle Connect: Це рішення орієнтоване на послуги прання з доставкою та не забезпечує детального моніторингу стану обладнання. Наша система надає функції моніторингу технічного стану пральних машин в реальному часі.
- Cleantie: Основний акцент зроблено на управлінні замовленнями та доставкою. Наша ж система пропонує додаткові можливості з управління запасами та оптимізації ресурсів, що значно розширює функціональність.
- CleanCloud: Хоча цей продукт також має функції управління замовленнями та автоматизації, він не забезпечує комплексної інтеграції з пральним обладнанням, що обмежує його ефективність у моніторингу та оптимізації роботи машин.
Основні переваги нашого програмного продукту включають:
- Інтеграція з пральним обладнанням: Система забезпечує повний моніторинг стану пральних машин, включаючи діагностику несправностей та автоматичне повідомлення про необхідність технічного обслуговування.
- Оптимізація ресурсів: Завдяки автоматичному розподілу навантаження на обладнання, система дозволяє зменшити витрати на електроенергію та воду.
- Управління запасами: Власники пралень можуть ефективно керувати запасами миючих засобів та іншими витратними матеріалами, що сприяє зниженню операційних витрат.
Модель монетизації нашого продукту передбачає наступні варіанти:
1. Підписка: Власники пралень сплачують щомісячну або щорічну плату за доступ до програмного забезпечення. Вартість підписки залежить від обсягу використання та обраних функціональних можливостей.
2. Оплата за використання: Плата встановлюється в залежності від кількості пральних машин, підключених до системи, та обсягу оброблених замовлень. Це забезпечує гнучкість та адаптацію витрат під конкретні потреби бізнесу.
3. Розширені функціональні пакети: Додаткові функції, такі як аналітика, звітність або інтеграція з іншими системами управління, можуть бути доступні за окрему плату.
Орієнтація на ринок бізнесу-до-бізнесу дозволяє нам звертатися до власників пралень як до цільової аудиторії, які зацікавлені в оптимізації своєї діяльності та підвищенні її ефективності. Згідно з дослідженнями ринку, індустрія пральних послуг зростає на 5% щорічно, а автоматизація бізнес-процесів стає все більш популярною (Джерело: "Індустрія пральних послуг: аналітика та прогнози", 2023).
Таким чином, наш програмний продукт є перспективним на ринку завдяки своїй унікальній функціональності та можливостям підвищення продуктивності пралень. Забезпечення гнучкої та ефективної системи управління пралнями відкриває широкі можливості для підвищення продуктивності та доходності цього бізнесу.


1.1.2 Бізнес-цілі та критерії успіху


BO-1: Зниження витрат на обслуговування пральних машин у громадських пральнях на 30% протягом першого року експлуатації програмної системи.
BO-2: Підвищення ефективності використання ресурсів: енергії, води, мийних засобів, у пралнях на 20% протягом перших шести місяців після впровадження програмного забезпечення.
BO-3: Забезпечення підвищення рівня автоматизації управління пралнями на 50% протягом першого року використання програми.
SC-1: Реєстрація не менше ніж 1000 клієнтів-власників пралень для використання програмної системи протягом перших трьох місяців після випуску продукту.
SC-2: Зниження часу, витраченого на адміністративні операції, у власників пралень на 40% протягом першого року використання програмного забезпечення.
SC-3: Підвищення задоволення клієнтів від обслуговування у громадських пральнях на 25% протягом перших шести місяців після впровадження системи автоматизації.


1.1.3 Потреби клієнтів або ринку


У сучасному світі, де швидкість, зручність та якість є ключовими критеріями вибору послуг, власники громадських пральень постійно шукають способи оптимізації своєї діяльності та покращення обслуговування для своїх клієнтів. Отже, головною потребою на ринку є наявність надійного та ефективного інструменту для автоматизації управління пральними машинами та бізнес-процесами пралень.
Клієнти, які володіють громадськими пральнями, потребують програмного забезпечення, яке забезпечить їм можливість ефективного моніторингу та управління станом обладнання, витратами ресурсів (такими як енергія та вода), а також запасами мийних засобів і пральних реагентів. Вони також потребують системи, яка надасть їм можливість віддалено керувати пралними та сушильними машинами, а також отримувати повідомлення про статус обладнання та несправності.
Ринок також потребує програмного рішення, яке забезпечить інтеграцію з іншими системами підтримки прийняття рішень, такими як системи планування ресурсів підприємства (ERP), для оптимізації управлінських процесів та підвищення ефективності діяльності пралень.
Отже, створення програмної системи, яка відповідає цим потребам, стане ключовим фактором успіху на ринку програмного забезпечення для громадських пральень.


1.1.4 Бізнес-ризики


В процесі розробки програмної системи автоматизації для громадських пральень існують різні бізнес-ризики, які можуть вплинути на успіх проєкту. Одним із головних ризиків є конкуренція на ринку програмного забезпечення для пральень, оскільки існують інші компанії, які пропонують схожі продукти. Щоб подолати цей ризик, необхідно провести ретельний аналіз конкурентного середовища та виявити переваги нашого програмного рішення, які роблять його більш привабливим для власників пралень.
Іншим потенційним ризиком є технічні проблеми та недоліки в розробці програмного забезпечення, які можуть призвести до затримок у випуску продукту або до нестабільної роботи системи. Для уникнення цього ризику необхідно провести ретельне тестування програми на різних етапах розробки та враховувати фідбек від користувачів для виправлення виявлених недоліків.
Також ризиком є невдалий ринковий впровадження програмного продукту через недостатню або неефективну маркетингову стратегію. Щоб запобігти цьому, необхідно провести обширне дослідження цільового ринку та розробити ефективний план маркетингу та продажу, який буде забезпечувати правильне позиціонування нашого продукту та привертати увагу потенційних клієнтів.
Крім того, важливо враховувати ризики, пов'язані з безпекою даних та приватністю користувачів, оскільки наша програма буде обробляти конфіденційну інформацію про бізнес-процеси власників пралень. Для зменшення цього ризику, необхідно використовувати найсучасніші технології захисту даних та відповідати всім вимогам щодо захисту персональних даних.


1.2 Концепція рішення
1.2.1 Окреслення концепції


Наша програмна система призначена для автоматизації роботи пральних машин у громадських пральнях з метою підвищення ефективності та оптимізації бізнес-процесів власників пралень. Ми прагнемо створити комплексний інструмент, який дозволить власникам пралень ефективно контролювати та управляти робочими процесами, зменшуючи витрати ресурсів та часу, необхідного для виконання рутинних завдань.
Наша система забезпечуватиме:
- Моніторинг стану пральних машин та сушильних апаратів: Програма дозволить власникам пралень в реальному часі отримувати інформацію про технічний стан обладнання, діагностувати несправності та автоматично повідомляти про необхідність технічного обслуговування.
- Звіти та аналітика: Система надаватиме детальні звіти та аналітику щодо ефективності використання обладнання, витрат енергії, води та інших ресурсів, що допоможе виявити можливості для зниження витрат.
- Управління запасами: Власники пралень зможуть вести облік запасів мийних засобів, пральних реагентів та іншого необхідного обладнання для забезпечення безперебійної роботи пралень.
- Автоматизація рутинних завдань: Система дозволить автоматизувати виконання рутинних завдань, таких як очищення та дезінфекція обладнання згідно з заданим розкладом.
Особливістю нашої системи є її унікальна можливість віддаленого управління обладнанням та інтеграції з іншими системами підтримки прийняття рішень, що підвищує її функціональність та зручність для користувачів. 
Ми врахували потреби власників пралень, які потребують надійного інструменту для підвищення ефективності їхньої діяльності, зниження витрат та покращення якості обслуговування клієнтів. Наша система дозволить оптимізувати управлінські процеси, що призведе до загального підвищення ефективності бізнесу.
Основні переваги нашої програмної системи включають:
- Інтеграція з іншими системами: Можливість інтеграції з існуючими системами управління та моніторингу, що забезпечить зручність та комплексність управління пральнями.
- Гнучкість та масштабованість: Система може бути адаптована під різні розміри бізнесу, від невеликих пралень до великих мережевих компаній, що робить її універсальним інструментом.
Наша мета полягає у створенні програмного рішення, яке стане незамінним інструментом для власників пралень, допомагаючи їм оптимізувати управлінські процеси, знижувати витрати та підвищувати якість обслуговування. Це призведе до загального підвищення ефективності їхнього бізнесу та задоволення клієнтів.


1.2.2 Головна функціональність


MF-1. Моніторинг стану обладнання: Моніторинг стану пральних машин та сушильних апаратів з можливістю відображення в реальному часі параметрів, таких як температура, час прання, стан завантаження та інші важливі показники.
MF-2. Звіти та аналітика: Надання звітів та аналітики щодо ефективності роботи пралень, включаючи витрати енергії, води та інших ресурсів. Користувачі зможуть отримувати статистику за потреби та аналізувати її для прийняття оптимальних управлінських рішень.
MF-3. Управління запасами: Управління запасами мийних засобів, пральних реагентів та іншого необхідного обладнання для забезпечення безперебійної роботи пралень. Система буде вести облік запасів та надавати повідомлення про необхідність поповнення.
MF-4. Віддалене управління: Можливість віддаленого управління пральними та сушильними машинами. Власники пралень матимуть можливість віддалено вмикати, вимикати та контролювати робочі процеси обладнання з будь-якого місця за допомогою мобільного пристрою або комп'ютера.
MF-5. Інтеграція з ERP системами: Інтеграція з системами підтримки прийняття рішень, такими як системи планування ресурсів підприємства (ERP), для оптимізації управлінських процесів та координації діяльності пралень з іншими підрозділами бізнесу.
MF-6. Автоматизація рутинних завдань: Автоматичне виконання рутинних завдань, таких як очищення та дезінфекція обладнання згідно з заданим розкладом для забезпечення дотримання гігієнічних стандартів та підвищення ефективності роботи.
MF-7. Підтримка мережевих функцій: Підтримка мережевих функцій, що дозволить керувати декількома пральнями через централізовану систему керування для оптимізації виробничих процесів та ресурсів.
MF-8. Повідомлення та сповіщення: Надсилання повідомлень та сповіщень операторам про зміни статусу обладнання, несправності або необхідність технічного обслуговування.
MF-9. Безпека даних: Забезпечення захисту конфіденційності та цілісності даних користувачів за допомогою шифрування, автентифікації та контролю доступу, що є критичним для програм, що обробляють особисті та комерційні інформаційні дані.
MF-10. Гнучкість налаштувань: Можливість налаштування та адаптації програмної системи до індивідуальних потреб кожної пральні, що дозволить враховувати специфічні вимоги та оптимізувати роботу залежно від масштабів та особливостей бізнесу.
MF-11. Масштабованість системи: Система буде розроблена з урахуванням можливості масштабування для використання в пральнях будь-якого масштабу – від невеликих до великих, що забезпечить її універсальність та відповідність різним потребам бізнесу.


1.2.3 Припущення та залежності


У рамках розробки програмної системи автоматизації роботи пральних машин в громадських пральнях, ми базуємося на наступних припущеннях та залежностях:
1. Адаптація прального обладнання. Припускається, що пральні машини, до яких буде підключатися наше програмне забезпечення, мають сумісність з необхідними інтерфейсами для передачі даних та керування.
2. Інтернет-підключення. Залежність від наявності стабільного Інтернет-підключення у пральнях, оскільки система передбачає віддалений доступ та обмін даними.
3. Технічна підтримка. Припускається, що власники пралень забезпечать необхідну технічну підтримку для встановлення та функціонування програмної системи.
4. Доступність даних про прання. Залежність від можливості отримання необхідних даних про процес прання з прального обладнання для їх подальшої обробки та аналізу.
5. Правові обмеження. Припускається, що використання програмного забезпечення буде відповідати всім вимогам законодавства щодо захисту даних та конфіденційності.
6. Сумісність з іншими системами. Залежність від можливості інтеграції нашої програмної системи з існуючими системами управління та обліку в пральнях.
Ці припущення та залежності є ключовими для успішного впровадження та ефективної роботи програмної системи у громадських пральнях та підприємствах-власниках пралень.


1.3 Рамки та обмеження проєкту
1.3.1 Рамки первинного випуску


У рамках першого випуску програмного продукту буде реалізована базова функціональність. Нижче наведено опис функцій для кожної складової системи: серверної частини, IoT пристрою, веб- та мобільного застосунку.
Серверна частина:
1. Збір та обробка даних: Серверна частина буде відповідальна за збір та обробку даних, що надходять з прального обладнання через IoT пристрої. Використовуватимуться ефективні математичні методи для аналізу даних у контексті бізнес-логіки.
2. Управління даними: Забезпечення надійного зберігання та керування даними про стан пральних машин та роботу пралень. Система дозволить управляти функціями та сутностями, пов’язаними з бізнес-логікою, а також користувачами системи.
3. Автентифікація та безпека: Реалізація механізмів автентифікації користувачів та забезпечення захисту даних. Будуть застосовуватися сучасні методи шифрування для забезпечення конфіденційності та цілісності інформації.
IoT пристрій:
1. Збір даних: IoT пристрій буде відповідати за збір та передачу даних про стан прального обладнання на сервер для подальшої обробки та аналізу.
2. Керування обладнанням: Можливість віддаленого керування пральним обладнанням через IoT пристрій для включення, вимкнення та моніторингу його роботи.
3. Адміністрування пристрою: IoT пристрій матиме можливості адміністрування, такі як управління даними пристрою, експорт та імпорт даних та налаштування пристрою.
Веб-застосунок:
1. Моніторинг стану: Перегляд реального часу стану пральних машин та сушильних апаратів у громадських пральнях.
2. Генерація звітів: Можливість створення звітів та аналітики щодо ефективності роботи пралень на основі зібраних даних.
3. Адміністрування: Функціонал для адміністрування системи, включаючи керування користувачами та налаштування системи.
4. Локалізація та інтернаціоналізація: Веб-застосунок підтримуватиме різні мовні версії та формати дати і часу для забезпечення інтернаціоналізації.
Мобільний застосунок:
1. Дистанційне управління: Можливість віддаленого керування пральним обладнанням через мобільний додаток.
2. Сповіщення: Отримання сповіщень про статус прання та несправності обладнання на мобільний пристрій користувача.
3. Захист даних та управління сертифікатами: Мобільний застосунок забезпечить захист даних відповідно до вимог GDPR, включаючи управління сертифікатами та інші заходи безпеки для захисту конфіденційної інформації користувачів.
Таким чином, перший випуск нашої програмної системи буде включати всі необхідні функціональні можливості для успішного запуску проєкту, забезпечуючи ефективність та безпеку роботи пралень, а також гнучкість у налаштуванні та масштабуванні системи відповідно до потреб користувачів.


1.3.2 Рамки наступних випусків


У цьому підрозділі описується функціональність, яка планується реалізувати у майбутніх випусках програмного продукту. Описана функціональність повинна бути здійсненною та спрямована на подальше розширення можливостей системи.
1. Розширений моніторинг пральних процесів. Розширення можливостей моніторингу для включення аналізу різних параметрів прання, таких як температура, оберти барабану та тривалість циклу.
2. Оптимізація ресурсів. Додаткові функції для аналізу та оптимізації використання ресурсів, таких як енергія та вода, з метою зменшення витрат та підвищення ефективності прання.
3. Розширені можливості аналітики. Введення додаткових інструментів аналізу даних для надання власникам пралень більш детальної інформації щодо ефективності їх бізнесу та підвищення продуктивності.
4. Розширені засоби керування. Додаткові можливості для віддаленого керування пральним обладнанням та налаштування параметрів прання через веб-інтерфейс або мобільний додаток.
5. Інтеграція з додатковими системами. Розробка API та інтеграція з системами планування ресурсів підприємства (ERP) та іншими програмними рішеннями для оптимізації управлінських процесів та забезпечення сумісності з іншими інформаційними системами.
6. Підтримка різних типів прального обладнання. Розширення можливостей для інтеграції з різними типами та моделями прального обладнання для покриття потреб різних клієнтів.
Ця функціональність буде реалізована у майбутніх випусках програмного продукту для подальшого розширення можливостей системи та задоволення потреб власників пралень у галузі автоматизації роботи прального обладнання.


1.3.3 Обмеження та винятки


У цьому підрозділі перераховуються обмеження, які впливають на роботу системи, та надається опис пов'язаних з експлуатацією системи винятків.
1. Обмеження щодо типів прального обладнання. Система буде розроблена для інтеграції з певними типами прального обладнання. Однак, існує можливість, що деякі моделі або типи пральних машин можуть мати обмежену або неповну сумісність з програмною системою.
2. Технічні обмеження інтеграції. Інтеграція з існуючими інформаційними системами пралень може бути обмежена технічними характеристиками цих систем або відсутністю необхідних API.
3. Обмеження щодо функціональності IoT пристроїв. Деякі функції IoT пристроїв, такі як зчитування деяких сенсорних даних або взаємодія зі сторонніми пристроями, можуть бути обмежені апаратними характеристиками пристроїв або їх програмним забезпеченням.
4. Виключення щодо встановлення і технічної підтримки. Система не надає послуги з встановлення та технічної підтримки пральних машин. Власники пралень мають забезпечити встановлення та підтримку обладнання самостійно або залучити сторонніх постачальників.
5. Безпекові обмеження. Система не гарантує повну захищеність від потенційних кібератак або порушень безпеки, і власники пралень повинні приділяти увагу вдосконаленню своїх систем безпеки.
6. Масштабність обмежень. При великому обсязі даних та інтенсивному використанні системи можливі перебої у роботі або затримки у відповідях.
7. Правові обмеження. Система повинна дотримуватися відповідних законодавчих норм і правил щодо захисту даних користувачів та інших правових аспектів, що можуть впливати на функціонування системи.
Ці обмеження та винятки повинні бути враховані при розробці та експлуатації програмної системи автоматизації роботи пральних машин.


1.4 Бізнес-контекст
1.4.1 Профілі зацікавлених сторін


Таблиця 1 – Профілі зацікавлених сторін проєкту
Зацікавлена
сторона
Головна
цінність
Ставлення
Головний
інтерес
Обмеження
Власники громадських пральень
Автоматизація процесів прання та управління
Позитивне
Підвищення ефективності пралень, зменшення витрат
Технічні обмеження інтеграції з існуючим обладнанням пралень
Клієнти пралень
Захист особистих даних клієнтів
Критичне
Забезпечення конфіденційності та безпеки особистих даних
Потреба у високій ступені безпеки та захищеності даних клієнтів
Адміністра-тори пралень
Оптимізація управління пральними машинами
Позитивне
Швидка обробка даних, забезпечення стабільності роботи
Масштабність та ефективність системи при великому обсязі даних
Виробники прального обладнання
Широкі можливості вибору обладнання
Позитивне
Універсальність і гнучкість системи
Сумісність з різними типами прального обладнання
Оператори пралень
Легкість в управлінні та моніторингу
Позитивне
Зручний та інтуїтивно зрозумілий інтерфейс
Спрощення процесу управління та моніторингу стану пралок
Екологічні організації та зацікавлені групи
Екологічна ефективність
Позитивне
Зменшення витрат та збереження ресурсів
Підвищення ефективності використання ресурсів (води, енергії)


1.4.2 Пріоритети проєкту


Таблиця 2 – Пріоритети проєкту
Показник
Виконання
Обмеження
Ступінь свободи
Час виконання
Завершення проєкту протягом 12 місяців
Потреба виконати проєкт у встановлені строки
Від +2 місяців до ‑1 місяця від планового строку
Бюджет
Витрати в межах 
1,000,000 доларів 
США
Обмежений 
бюджет на 
реалізацію 
проєкту
До 10% зміни в 
бюджеті
Функціональність
Постачання 
основних функцій 
у початковому 
випуску
Обмежені ресурси 
для реалізації 
додаткових 
функцій
Збереження 
основного 
функціоналу у 
першому випуску
Якість
Забезпечення 
стабільної та 
надійної роботи 
системи
Відсутність 
високих вимог до 
якості та 
надійності 
системи
Збереження 
стандартів якості 
та надійності
Ресурси
Мінімальне використання 
зовнішніх ресурсів
Обмежена 
доступність 
спеціалістів та 
обладнання
Можливість 
залучення 
додаткових 
ресурсів за 
потреби
Співпраця
Активне спілкування та 
співпраця між командами
Різні часові зони 
та мовні бар’єри
Забезпечення 
ефективного 
спілкування та 
координації


1.4.3 Робоче середовище


У цьому підрозділі описано технології та програмні засоби, які будуть використані у проєкті, включаючи інформацію про програмні платформи, СУБД, фреймворки, програмні бібліотеки та мови програмування. Також визначено основні вимоги щодо доступності, надійності, продуктивності та цілісності.
Серверна частина
- Платформа: Серверна частина буде розроблена на платформі .NET із застосуванням фреймворку ASP.NET Core [1]. Це обрано через високу продуктивність, масштабованість та надійність, яку пропонує ця платформа. 
- Технології доступу до даних: Microsoft Entity Framework Core для зручного та ефективного ORM.
- СУБД: PostgreSQL [5] вибрано за її стабільність, продуктивність і підтримку складних запитів.
- Інтерфейс взаємодії: HTTP REST забезпечує стандартизований та простий спосіб обміну даними.
- Автентифікація та безпека: Інтеграція з LDAP та OAuth2 для забезпечення надійної автентифікації користувачів.
- Масштабування та висока доступність: Для забезпечення масштабованості буде використовуватись контейнеризація (Docker) та оркестрація контейнерів (Kubernetes). Високу доступність забезпечать кластерні конфігурації серверів та механізми резервного копіювання даних.
Веб-застосунок
- Технології: Веб-застосунок буде розроблений із використанням JavaScript бібліотеки React [6] та фреймворку NextJs [2]. React обрано за його гнучкість і багатий екосистемний ландшафт, а NextJs — за можливості серверного рендерингу та покращення продуктивності.
- Безпека: Засоби забезпечення безпеки включатимуть механізми захисту від CORS, XSS та CSRF атак, а також використання HTTPS для шифрування переданих даних.
- Локалізація та інтернаціоналізація: Веб-застосунок підтримуватиме різні мовні версії та формати дати і часу для забезпечення інтернаціоналізації.
Мобільний застосунок
- Технології: Мобільний застосунок буде розроблений під Android із застосуванням інтегрованого середовища розробки Android Studio, мови програмування Kotlin та фреймворку для побудови інтерфейсів Compose [3]. Kotlin обрано за його сучасні можливості та безпечність у порівнянні з Java.
- Безпека: Для забезпечення безпеки мобільного застосунка будуть використовуватися HTTPS для захищеного зв’язку, механізми обробки винятків, а також валідація даних та управління сертифікатами відповідно до вимог GDPR.
IoT система
- Платформа: IoT система буде розроблена на платформі .NET, використовуючи одноплатні комп’ютери Raspberry Pi.
- Функціональність: IoT пристрій буде відповідальний за збір та передачу даних про стан прального обладнання на сервер для подальшої обробки та аналізу. Можливість віддаленого керування пральним обладнанням буде здійснюватися через IoT пристрій.
- Адміністрування пристрою: IoT пристрій матиме можливості адміністрування, такі як управління даними пристрою, експорт та імпорт даних та налаштування пристрою.
Інфраструктура
- Розгортання: Використання приватних серверів з застосуванням зворотного проксі Nginx для балансування навантаження та забезпечення високої доступності.
- Контроль версій та CI/CD: Для контролю версій, менеджменту проєкту та CI/CD будуть використовуватися Git та Gitea, що забезпечить стабільність розробки та швидке впровадження змін.
Основні вимоги
- Доступність: Висока доступність забезпечуватиметься через кластерні конфігурації серверів, резервне копіювання та механізми відновлення.
- Надійність: Надійність системи буде досягатися за рахунок використання перевірених технологій, резервування компонентів та регулярного моніторингу.
- Продуктивність: Продуктивність буде оптимізована за допомогою ефективного коду, кешування даних та розподілу навантаження.
- Цілісність даних: Забезпечуватиметься механізмами резервного копіювання, контролю версій та шифруванням даних на всіх рівнях системи.
Ці технології та заходи забезпечать надійне, продуктивне та безпечне функціонування системи автоматизації роботи пральних машин у громадських пральнях.


2 ПРОЄКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
2.1 Проєктування серверної частини проєкту
2.1.1 Проєктування діаграм


Перед тим як створювати серверну частину, потрібно чітко описати всі елементи, які будуть використовуватися для реалізації визначених функцій. Для цього можна скласти ER-модель даних, яка дозволить візуалізувати всі ці елементи та зв'язки між ними. Після визначення всіх необхідних елементів була створена діаграма, що показана в додатку А.1.
Після визначення всіх елементів слід переходити до опису основних сценаріїв використання програмної системи. Після аналізу функціоналу, який був визначений у документі «Концепції та рамки проєкту», була розроблена UML діаграма прецедентів, наведена в додатку А.2, на якій зображено два актори: користувач та адміністратор.
Користувач може змінювати режим роботи пральної машини.
Адміністратор може змінювати будь-які сутності в бази даних та отримувати необхідну інформацію. Він має доступ до всіх функцій системи, а саме: пошук пральних машин в мережі, додання їх до бази даних, зміна режиму прання та отримання даних з датчиків.


2.1.2 Високорівнева архітектура та технології


Технології для написання серверної частини були відібрані на підставі потреб системи та особистого досвіду. Отже, для цієї частини була обрана платформа .NET 8. REST-специфікація орієнтується на архітектурний стиль, який акцентує використання ресурсів та їх ідентифікацію через URI. Були використані контролери ASP.NET Core [1] для створення RESTful веб-сервісів, що дотримуються принципів архітектурного стилю REST.
Для бази даних була обрана PostgreSQL [5] через її надійність та високу продуктивності у роботі з даними. PostgreSQL надає потужні можливості роботи з реляційними даними та дозволяє ефективно масштабувати систему, забезпечуючи швидкий доступ до інформації. Серверна частина взаємодіє з базою даних за допомогою об’єктно-реляційного перетворювача Entity Framework Core.
Комунікація між сервером і клієнтською частиною, включаючи мобільний додаток, також здійснюється за допомогою REST API. Більш детальний огляд взаємодії серверної частини з іншими елементами системи можна знайти на UML-діаграмі розгортання, що показана в додатку А.3.
Комунікація між сервером IoT пристроєм, здійснюється за допомогою протоколу MQTT [4]. Пошук пральних машин, зміна параметрів їх роботи та отримання параметрів, зчитаних з датчиків, відбувається за допомогою публікації повідомлень за певними темами, що були погоджені раніше. Ці запити надсилаються до MQTT брокера – сервера, що комутує їх до потрібного пристрою. Кожен із вузлів підписується на теми, з яких хоче отримувати повідомлення.
Архітектура системи, ґрунтується на ключових принципах «Чистої Архітектури» відповідно до однойменної книги Роберта Сесіла Мартіна. З метою досягнення максимальної ефективності та лаконічності функціонування програмного комплексу, він був структурований у формі п'яти основних проєктів: Api, Application, Infrastructure, Persietence, Domain.
Кожен із зазначених проєктів відповідав за конкретний аспект системи, чітко визначаючи свою роль та функціональні обов'язки. Проєкт Api відповідає за представлення інформації користувачу, у нашому випадку через RESTful Web API. Application реалізує бізнес-логіку та основні функціональні можливості системи. Саме в цьому проєкті відбувається оброблення запитів користувача, формування та повернення інформації. Infrastructure забезпечує інфраструктурні потреби програмного забезпечення, включаючи комунікацію між різними компонентами системи та їх взаємодію з зовнішніми системами, наприклад: комунікація із системою ідентифікації користувачів, що зберігає та керує даними про облікові записи, взаємодія із сервером електронної пошти. Persistence відповідає за роботу з базами даних та доступ до інформації. Він допомагає абстрагувати логіку доступу до даних, що робить систему незалежною від вибору СУБД. Нарешті, Domain сконцентрований на бізнес-логіці, моделях даних та специфічних вимогах домену програмного продукту.
Ця структура відображена на діаграмі пакетів, що показана в додатку А.4.
Обрана архітектура дозволила ефективно розподілити відповідальність між окремими компонентами системи, забезпечивши їхню модульність та можливість взаємодії без надмірних залежностей. Кожен проєкт був організований таким чином, щоб мати чітку структуру та відокремленість від інших, сприяючи підтримці, розширенню та розвитку системи в майбутньому.



2.1.3 Специфікація REST


Таблиця 3 – Специфікація REST API
Сутність
HTTP Метод
Посилання
Дія
Пральна машина
POST
/washingMachines
Створення пральної машини

GET
/washingMachines
Отримання сторінок пральних машин

PUT
/washingMachines
Оновлення пральної машини

DELETE
/washingMachines
Видалення пральної машини

GET
/washingMachines/{id}
Отримання пральної машини

GET
/washingMachines/discover
Отримання пральних машин, підключених до мережі

POST
/washingMachines/changeState
Зміна режиму прання

GET
/washingMachines/{id}/streamStatus
Отримання даних з датчиків

Продовження таблиці 3
Сутність
HTTP Метод
Посилання
Дія
Група пристроїв
POST
/deviceGroups
Створення групи пристроїв

GET
/deviceGroups
Отримання сторінок груп пристроїв

PUT
/deviceGroups
Оновлення групи пристроїв

DELETE
/deviceGroups
Видалення групи пристроїв

GET
/deviceGroups/{id}
Отримання групи пристроїв
Аутен-тифікація
POST
/identity/register
Реєстрація облікового запису

POST
/identity/login
Отримання токена аутентифікації

POST
/identity/renewAccessToken
Оновлення токена аутентифікації

POST
/identity/revokeRefreshToken
Скасування токена оновлення



2.2 Проєктування IoT частини проєкту
2.2.1 Проєктування діаграм


Для опису поведінки системи використовується UML діаграма прецедентів. Повну діаграму системи було наведено в попередній лабораторній роботі. На рисунку, що наведений в додатку В.1 зображено діаграму прецедентів тільки для IoT пристроїв системи. Користувач може налаштовувати систему, зберігати та відновлювати файл конфігурації, подавати команди зміни режиму роботи пральної машини, отримувати дані з датчиків. Система відповідає на запити MQTT [4] брокера.
Діаграма взаємодії, що показана в додатку В.2, відображає перебіг процесів у формі вузлів активності та контрольних вузлів, які представляють собою різні типи взаємодії, такі як виклик операцій, послідовність подій або паралельні процеси. Кожен вузол активності має діаграму послідовності, що описує кроки виконання активності та взаємодію між різними частинами системи. 
Користувач задає посилання на серер, запускає систему. Пристрій відповідає на запити MQTT брокера. Це відбувається доки система не отримала повідомлення про зупинку роботи.
Діаграма діяльності представляє потоки робочого процесу або операцій 
в системі. Вона відображає послідовність кроків та контрольну структуру, які описують, як діяльності виконуються для досягнення певної мети. На рисунку, що наведений в додатку В.3 наведено діаграму діяльності для роботи точки пристрою.
Процес починається після запуску системи. Пристрій зчитує дані з різних датчиків та відповідає ними. Сервер перевіряє запит та вирішує чи повідомляти клієнта про надходження цих даних.
Діаграма компонентів, що показана в додатку В.4, використовується для моделювання фізичної структури системи. Інформацію оброблює одноплатний комп’ютер Raspberry Pi. Він має достатньо обчислювальної потужності для виконання описаних раніше задач, 40 контактів вводу-виводу для контролю датчиків та інших зовнішніх пристроїв та вбудований WiFi.


2.2.2 Високорівнева архітектура та технології


Описана система потребує розробки одного застосунку. Для спрощення розробки та підтримки програмного забезпечення, було прийнято низку загальних рішень.
Застосунок було написано на мові програмування С#, бо вона має велику кількість бібліотек, що спрощує та прискорює процес розробки.
Кожен пристрій потребує встановлення додатків і завантаження конфігурації, що містить посилання на MQTT брокера-для конфігурації використовується JSON файл.
Для комунікації від IoT пристрою до серверної частини використовується протокол MQTT, функціональність клієнта якого реалізована у бібліотеці MQTTnet. Пристрій підписується на загальний топік брокера «devices/discovery», у відповідь на запити до якого інформацію про пристрій, а саме: унікальний ідентифікатор, виробника, серійний номер та назву пральної машини. Також пристрій оброблює запити, що надходять із топіками «devices/*deviceId*/getStatus» та «devices/*deviceId*/changeState». У відповідь на перший надсилає дані з датчиків пральної машини, як-от: режим роботи, температуру води, швидкість обертання мотора та вага вмісту барабану. На другий запит просто змінюється режим роботи без надсилання відповіді. Усі відповіді на запити надсилаються із тим самим топіком. Серверна частина та IoT пристрій розрізняють їх приналежність за структурою посилання. Сервер приймає та оброблює лише ті запити, зо містять JSON об’єкт. IoT пристрою важливий саме топік запиту.


2.3 Проєктування клієнтської частини проєкту
2.3.1 Проєктування діаграм


Для опису поведінки системи використовується UML діаграма прецедентів. Користувач може отримати дані з датчиків пральної машини та змінити режим її роботи. Адміністратор може додавати, редагувати, оновлювати та видаляти дані пральних машин. Також йому доступний пошук пральних машин у мережі.
Діаграма компонентів, що показана в додатку Д.2, використовується для моделювання структури компонентів бібліотеки React [6]. Вона показує як вони складаються для відображення кінцевого результату інтерфейсу системи. Застосунок завантажує компонент «Layout», котрий вже відображує потрібні сторінки. У свою чергу сторінки показують форми, картки та інші компоненти.
Діаграма компонентів, що показана в додатку Д.3, показує бібліотеки, які потрібні для коректного функціонування застосунку.
Діаграма взаємодії, що показана в додатку Д.4, відображає перебіг процесів у формі вузлів активності та контрольних вузлів, які представляють собою різні типи взаємодії, такі як виклик операцій, послідовність подій або паралельні процеси. Кожен вузол активності має діаграму послідовності, що описує кроки виконання активності та взаємодію між різними частинами системи. 
Користувач входить в систему. Йому надається можливість виконання операцій над пральними машинами, перегляду інформації, що надходить з датчиків та сканувати мережу.


2.3.2 Структура та технології


Веб-застосунок побудовано з використанням сучасних веб-технологій та архітектурних підходів, що забезпечують високу продуктивність, масштабованість та підтримку.
Фронтенд веб-застосунку побудовано на основі фреймворку Next.js [2], який забезпечує серверний рендеринг і статичну генерацію сторінок. Використання Next.js дозволяє підвищити продуктивність та SEO-оптимізацію завдяки попередньому рендерингу сторінок.
Фронтенд застосунку побудовано на компонентному підході, де кожен компонент є незалежним модулем. Це забезпечує високу модульність та повторне використання коду. Файли компонентів розміщено у відповідних директоріях, таких як _components для кожної функціональної частини застосунку (наприклад, header.tsx, footer.tsx).
Структура директорій:
    • src/app: Основна директорія застосунку, що містить усі компоненти, стилі, бібліотеки та сторінки.
    • _components: Директорія, що містить реюзабельні компоненти інтерфейсу користувача.
    • _lib: Директорія з бібліотеками та утилітами, такими як api для взаємодії з API, context для управління контекстом (наприклад, AuthProvider.tsx), hooks для кастомних хуків.
    • _styles: Директорія зі стилями, розділеними за компонентами.
    • public: Директорія для статичних файлів, доступних напряму з браузера (наприклад, placeholder.svg).
TypeScript: Основна мова програмування для розробки застосунку. Використання TypeScript забезпечує статичну типізацію, що допомагає виявляти помилки на етапі розробки.


2.3.3 Реєстрація та вхід у систему


При розробці клієнтської частини для сторінок реєстрації та входу головним завданням було забезпечення безпеки та конфіденційності даних користувачів. Щоб ефективно застосувати механізм підтвердження особи на клієнтській стороні, було використано контекст, який служить для глобального зберігання та передачі даних по всьому додатку. У попередній лабораторній роботі для серверної частини використовували JWT токени для автентифікації та авторизації користувачів. Контекст використовувався для відстеження статусу користувача (перевірка автентифікації) та захисту маршрутів, доступ до яких повинен бути обмежений.


2.3.4 Головний функціонал


Основною сторінкою нашого застосунку є список пральних машин, яка дозволяє користувачеві переглядати всі пральні машини, а також здійснювати пошук і сортування. Для доступу до книжкової полиці на сервер надсилається запит із JWT токеном користувача в заголовку, що забезпечує безпечний доступ до даних і відображення лише його книжок.
Також створено сторінку з детальною інформацією про пральні машини, де користувач може переглядати дані та отримувати статус роботи пральної машини в реальному часі, а саме: етап прання, температуру води, швидкість обертання мотора та ін. Ця сторінка також дозволяє видаляти пральні машини з БД.
За допомогою навігаційного меню користувач може перейти на головну сторінку та сторінку пошуку пральних машин в мережі. Головна сторінка відображається першою після входу користувача у систему.
Сторінка додавання пральних машин має простий інтерфейс. Користувач може ввести виробника, серійний номер, назву та опис пральної машини.


2.4 Проєктування мобільного застосунку


Функціонал мобільного застосунку повторює веб-застосунок.


3 КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ
3.1 Кодування серверної частини проєкту
3.1.1 Реалізація сервісу для взаємодії з MQTT брокером


У конструкторі відбувається ініціалізація MQTT [4] клієнта (_mqttClient) та налаштування логування через ILogger.
Методі SubscribeToTopics дозволяє підписатися на один або кілька топіків у MQTT брокері. Він викликається при підключенні клієнта до брокера із можливістю вказати бажану якість обслуговування (QoS).
Метод PublishToTopicAsync дозволяє публікувати повідомлення у вказаний топік на MQTT брокері з певним рівнем якості обслуговування та опціями.
Метод SetHandleApplicationMessageReceivedAsync дозволяє встановити обробник для обробки отриманих повідомлень від брокера. Використовується для реакції на отримані повідомлення.
Методи StartAsync і StopAsync дозволяють запустити та зупинити клієнта MQTT асинхронно. Метод StartAsync спочатку підключається до брокера та потім виконує підтримку з'єднання, перевіряючи стан підключення через певний інтервал часу. Метод StopAsync розриває з'єднання з брокером.
Обробник HandleClientDisconnectedAsync викликається при втраті з'єднання з MQTT брокером. Він намагається встановити нове з'єднання та перепідключитися до брокера у разі втрати з'єднання.
Код наведений у додатку Б.1



3.1.2 Валідація даних, що надходять від користувача


Пакет FluentValidation для платформи .NET є бібліотекою, яка надає можливості валідації даних. У контексті архітектури CQRS (Command Query Responsibility Segregation), що застосовується в проєкті, використання FluentValidation дозволяє здійснювати перевірку вхідних даних на основі заданих правил до того, як команда або запит буде оброблена.
Код, наведений у додатку Б.2, представляє приклад використання FluentValidation для валідації даних, які надходять разом із командою «RegisterCommand». Клас «RegisterCommandValidator» успадковує від «AbstractValidator<RegisterCommand>», що є частиною інтерфейсу FluentValidation, та містить правила валідації для конкретних полів у команді реєстрації.
У цьому прикладі використано ланцюжок методів, які встановлюють правила валідації для полів «Email» та «Password». Наприклад, метод «RuleFor» встановлює правила для конкретного поля: в першому випадку – для «Email», а в другому - для «Password». Методи, які визначають правила валідації, як «NotEmpty», «MinimumLength», «MaximumLength», «Matches», використовуються для перевірки наявності даних, мінімальної та максимальної довжини, а також відповідності певним шаблонам (у випадку регулярних виразів). 
Наприклад, для поля «Email» використовується правило, що перевіряє наявність даних та відповідність формату адреси за допомогою регулярного виразу. Для поля «Password» встановлено правила стосовно його довжини, наявності різноманітних символів, включаючи прописні та малі літери, цифри та спеціальні символи.



3.2 Кодування IoT частини проєкту
3.2.1 Потік обробки інформації з датчика


Код, що по казаний у додатку Г.1, реалізує IoT пристрій пральної машини, який спілкується з MQTT брокером. Давайте розглянемо основні компоненти та функції:
    1. Підготовка і налаштування сервісів: Код створює об'єкти сервісів для управління температурою води (IWaterTemperatureService), швидкістю мотора (IMotorSpeedService), вагою завантаження (ILoadWeightService), станом кришки (ILidClosedService) та загальним станом пристрою (IStateService). У цьому випадку використовуються заміщені сервіси, що можуть бути корисними для тестування.
    2. Ініціалізація MQTT клієнта: Створюється клієнт MQTT з допомогою MQTTnet бібліотеки. Налаштування клієнта виконується за допомогою MqttClientOptionsBuilder.
    3. Обробники подій MQTT клієнта: Код призначає обробники подій для обробки підключення до брокера, прийому повідомлень та відключення від брокера. Наприклад, відповідно до надісланого повідомлення, викликаються відповідні методи для обробки.
    4. Очікування сигналу зупинки: Код створює CancellationToken, який служить для контролю зупинки роботи пристрою. Обробник зупинки встановлюється для перехоплення сигналу CTRL+C та запуску методу StopMqttClientAsync.
    5. Методи керування MQTT клієнтом: Ці методи відповідають за підключення та відключення клієнта від брокера MQTT. Крім того, вони включають автоматичну спробу підтримувати з'єднання з брокером через TryPingAsync.
    6. Обмін повідомленнями з пристроєм: Код виконує підписку на певні теми для прийому та відправлення повідомлень. В залежності від теми та отриманого повідомлення викликаються відповідні методи обробки.
Усе це дозволяє пральній машині спілкуватися з іншими пристроями чи контролерами через MQTT протокол.


ВИСНОВКИ


Під час виконання курсового проєкту було проведено концептуальне моделювання та аналіз предметної області. На основі цього аналізу було розроблено комплексну програмну систему, яка забезпечує підвищення ефективності роботи пральних машин в громадських пральнях.
Розробка включила створення концептуальної моделі предметної області, що дозволило краще зрозуміти потреби користувачів і визначити основні вимоги до системи. Було здійснено проектування фізичної моделі даних та реалізацію системи з використанням сучасних технологій програмування.
У результаті роботи було створено програмну систему, яка надає користувачам інструменти для ефективного управління процесом прання, забезпечуючи зручність доступу до інформації, організацію та моніторинг стану пральних машин. Для забезпечення надійності та зручності використання системи було проведено тестування, що включало перевірку коректності роботи всіх функцій та оцінку зручності інтерфейсу.
Результатом даного курсового проєкту є розроблена система для автоматизації роботи пральних машин в громадських пральнях, яка дозволяє користувачам легко керувати процесом прання, відслідковувати статус пральних машин та отримувати сповіщення про завершення циклу прання. Ця система є зручним інструментом для організації роботи громадських пралень, забезпечуючи простоту та ефективність управління.
Також був створений відеоролик [7] із функціональним тестуванням та описом аріхектури та прийнятих інженерних рішень усіх частин програмого продукту.


ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. ASP.NET documentation. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/aspnet/core (дата звернення: 01.04.2024).
2. Next.Js documentation. Next.Js - The React Framework. URL: https://nextjs.org/docs (дата звернення: 10.05.2024).
3. Jetpack Compose documentation. Android Developers. URL: https://developer.android.com/develop/ui/compose/documentation (дата звернення: 20.05.2024).
4. MQTTnet. GitHub. URL: https://github.com/dotnet/MQTTnet/wiki (дата звернення: 20.04.2024).
5. PostgreSQL documentation. URL: https://www.postgresql.org/docs (дата звернення: 05.04.2024).
6. React reference. URL: https://react.dev/reference/react (дата звернення: 10.05.2024).
7. Відео демонстрація тестування розробленого програмного забезпечення. URL: https://youtu.be/HHOihvxLPYA
8. GitHub репозиторій. URL: https://github.com/NureNazarkoDanylo/apzkr-pzpi-21-4-nazarko-danylo


ДОДАТОК А.
ДІАГРАМИ СЕРВЕРНОЇ ЧАСТИНИ

А.1 ER-модель даних
А.2 Діаграма прецедентів
А.3 Діаграма розгортання
А.4 Діаграма пакетів


ДОДАТОК Б.
КОД СЕРВЕРНОЇ ЧАСТИНИ

Б.1 Сервіс взаємодії з MQTT брокером


   1	using System.Diagnostics;
   2	using Microsoft.Extensions.Logging;
   3	using MQTTnet;
   4	using MQTTnet.Client;
   5	using MQTTnet.Protocol;
   6	
   7	namespace WashingMachineManagementApi.Application.Common.Services;
   8	
   9	public class MqttClientService
  10	{
  11	  private readonly IMqttClient _mqttClient;
  12	  private readonly MqttClientOptions _mqttClientOptions;
  13	  private readonly ILogger<MqttClientService> _logger;
  14	
  15	  public MqttClientService(MqttClientOptions options, ILogger<MqttClientService> logger)
  16	  {
  17	    _mqttClientOptions = options;
  18	    _logger = logger;
  19	
  20	    _mqttClient = new MqttFactory().CreateMqttClient();
  21	
  22	    _mqttClient.DisconnectedAsync += HandleClientDisconnectedAsync;
  23	  }
  24	
  25	  public void SubscribeToTopics(IEnumerable<string> topics)
  26	  {
  27	    _mqttClient.ConnectedAsync += async eventArgs =>
  28	    {
  29	      _logger.LogInformation(
  30	        "{@DateUtc} {@TimeUtc} {@TraceId} {@SpanId} Connected to MQTT Broker.",
  31	        DateTime.UtcNow.ToString("yyyy-MM-dd"),
  32	        DateTime.UtcNow.ToString("HH:mm:ss.FFF"),
  33	        Activity.Current?.TraceId.ToString(),
  34	        Activity.Current?.SpanId.ToString());
  35	
  36	      foreach (var topic in topics)
  37	      {
  38	        await _mqttClient.SubscribeAsync(topic, MqttQualityOfServiceLevel.AtMostOnce);
  39	      }
  40	    };
  41	  }
  42	
  43	  public async Task PublishToTopicAsync(string topic, string payload, CancellationToken cancellationToken)
  44	  {
  45	    // TODO: Handle result
  46	    var result = await _mqttClient.PublishStringAsync(topic, payload, MqttQualityOfServiceLevel.ExactlyOnce, false, cancellationToken);
  47	  }
  48	
  49	  private Func<MqttApplicationMessageReceivedEventArgs, Task> HandleApplicationMessageReceivedAsync = _ => Task.CompletedTask;
  50	
  51	  public void SetHandleApplicationMessageReceivedAsync(Func<MqttApplicationMessageReceivedEventArgs, Task> del)
  52	  {
  53	    foreach (Func<MqttApplicationMessageReceivedEventArgs, Task> d in HandleApplicationMessageReceivedAsync.GetInvocationList())
  54	    {
  55	      HandleApplicationMessageReceivedAsync -= d;
  56	      _mqttClient.ApplicationMessageReceivedAsync -= d;
  57	    }
  58	
  59	    HandleApplicationMessageReceivedAsync = del;
  60	    _mqttClient.ApplicationMessageReceivedAsync += HandleApplicationMessageReceivedAsync;
  61	  }
  62	
  63	  private async Task HandleClientDisconnectedAsync(MqttClientDisconnectedEventArgs eventArgs)
  64	  {
  65	    if (eventArgs.Reason == MqttClientDisconnectReason.NormalDisconnection)
  66	    {
  67	      _logger.LogWarning(
  68	          "{@DateUtc} {@TimeUtc} {@TraceId} {@SpanId} Disconnected from MQTT Broker.",
  69	          DateTime.UtcNow.ToString("yyyy-MM-dd"),
  70	          DateTime.UtcNow.ToString("HH:mm:ss.FFF"),
  71	          Activity.Current?.TraceId.ToString(),
  72	          Activity.Current?.SpanId.ToString());
  73	
  74	      return;
  75	    }
  76	
  77	    _logger.LogWarning(
  78	        "{@DateUtc} {@TimeUtc} {@TraceId} {@SpanId} Lost connection with MQTT Broker. Reason: {@Reason}. Trying to reconnect.",
  79	        DateTime.UtcNow.ToString("yyyy-MM-dd"),
  80	        DateTime.UtcNow.ToString("HH:mm:ss.FFF"),
  81	        Activity.Current?.TraceId.ToString(),
  82	        Activity.Current?.SpanId.ToString(),
  83	        eventArgs.Reason);
  84	
  85	    _ = Task.Run(
  86	      async () =>
  87	      {
  88	        while (true)
  89	        {
  90	          try
  91	          {
  92	            if (!await _mqttClient.TryPingAsync())
  93	            {
  94	              await _mqttClient.ConnectAsync(_mqttClient.Options);
  95	              _logger.LogWarning(
  96	                  "{@DateUtc} {@TimeUtc} {@TraceId} {@SpanId} Reconnected to MQTT Broker.",
  97	                  DateTime.UtcNow.ToString("yyyy-MM-dd"),
  98	                  DateTime.UtcNow.ToString("HH:mm:ss.FFF"),
  99	                  Activity.Current?.TraceId.ToString(),
  100	                  Activity.Current?.SpanId.ToString());
  101	            }
  102	          }
  103	          catch (Exception exeption)
  104	          {
  105	            _logger.LogError(
  106	                "{@DateUtc} {@TimeUtc} {@TraceId} {@SpanId} Failed connecting to MQTT Broker. {@Exception}",
  107	                DateTime.UtcNow.ToString("yyyy-MM-dd"),
  108	                DateTime.UtcNow.ToString("HH:mm:ss.FFF"),
  109	                Activity.Current?.TraceId.ToString(),
  110	                Activity.Current?.SpanId.ToString(),
  111	                exeption);
  112	          }
  113	          finally
  114	          {
  115	            await Task.Delay(TimeSpan.FromSeconds(5));
  116	          }
  117	        }
  118	      });
  119	
  120	    await Task.CompletedTask;
  121	  }
  122	
  123	  public async Task StartAsync(CancellationToken cancellationToken)
  124	  {
  125	    await _mqttClient.ConnectAsync(_mqttClientOptions);
  126	
  127	    _ = Task.Run(
  128	      async () =>
  129	      {
  130	        while (!cancellationToken.IsCancellationRequested)
  131	        {
  132	          try
  133	          {
  134	            // This code will also do the very first connect! So no call to _ConnectAsync_ is required in the first place.
  135	            if (!await _mqttClient.TryPingAsync())
  136	            {
  137	              await _mqttClient.ConnectAsync(_mqttClient.Options, cancellationToken);
  138	
  139	              // Subscribe to topics when session is clean etc.
  140	              Console.WriteLine("The MQTT client is connected.");
  141	            }
  142	          }
  143	          catch (Exception ex)
  144	          {
  145	            // Handle the exception properly (logging etc.).
  146	            Console.WriteLine("The MQTT client connection failed" + ex);
  147	          }
  148	          finally
  149	          {
  150	            // Check the connection state every 5 seconds and perform a reconnect if required.
  151	            await Task.Delay(TimeSpan.FromSeconds(5));
  152	          }
  153	        }
  154	      });
  155	  }
  156	
  157	  public async Task StopAsync(CancellationToken cancellationToken)
  158	  {
  159	    if (cancellationToken.IsCancellationRequested)
  160	    {
  161	      var disconnectOption = new MqttClientDisconnectOptions
  162	      {
  163	        Reason = MqttClientDisconnectOptionsReason.NormalDisconnection
  164	      };
  165	
  166	      await _mqttClient.DisconnectAsync(disconnectOption, cancellationToken);
  167	    }
  168	
  169	    await _mqttClient.DisconnectAsync();
  170	  }
  171	}


Б.2 Приклад валідації запиту на реєстрацію


   1	using FluentValidation;
   2	
   3	namespace WashingMachineManagementApi.Application.Authentication.Commands.Register;
   4	
   5	public class RegisterCommandValidator : AbstractValidator<RegisterCommand>
   6	{
   7	  public RegisterCommandValidator()
   8	  {
   9	    // https://regexr.com/2ri2c
  10	    RuleFor(v => v.Email)
  11	      .NotEmpty().WithMessage("Email address is required.")
  12	      .Matches(@"\b[\w\.-]+@[\w\.-]+\.\w{2,4}\b").WithMessage("Email address is invalid.");
  13	
  14	    RuleFor(v => v.Password)
  15	      .NotEmpty().WithMessage("Password is required.")
  16	      .MinimumLength(8).WithMessage("Password must be at least 8 characters long.")
  17	      .MaximumLength(64).WithMessage("Password must be at most 64 characters long.")
  18	      .Matches(@"(?=.*[A-Z]).*").WithMessage("Password must contain at least one uppercase letter.")
  19	      .Matches(@"(?=.*[a-z]).*").WithMessage("Password must contain at least one lowercase letter.")
  20	      .Matches(@"(?=.*[\d]).*").WithMessage("Password must contain at least one digit.")
  21	      .Matches(@"(?=.*[!@#$%^&*()]).*").WithMessage("Password must contain at least one of the following special charactters: !@#$%^&*().");
  22	  }
  23	}


ДОДАТОК В.
ДІАГРАМИ IoT ЧАСТИНИ

В.1 Діаграма прецедентів
В.2 Діаграма взаємодії
В.3 Діаграма діяльності
В.4 Діаграма компонентів


ДОДАТОК Г.
КОД IOT ЧАСТИНИ

Г.1 Головна програма обробки запитів MQTT брокера


   1	﻿using System.Text;
   2	using MQTTnet;
   3	using MQTTnet.Client;
   4	using MQTTnet.Protocol;
   5	using Newtonsoft.Json;
   6	using Newtonsoft.Json.Serialization;
   7	using WashingMachineManagementIot.Models.Responses;
   8	using WashingMachineManagementIot.Models;
   9	using WashingMachineManagementIot.Services;
  10	
  11	JsonConvert.DefaultSettings = () => new JsonSerializerSettings
  12	{
  13	  ContractResolver = new CamelCasePropertyNamesContractResolver()
  14	};
  15	
  16	IWaterTemperatureService waterTemperatureService = new MockWaterTemperatureService();
  17	IMotorSpeedService motorSpeedService = new MockMotorSpeedService();
  18	ILoadWeightService loadWeightService = new MockLoadWeightService();
  19	ILidClosedService lidClosedService = new MockLidClosedService();
  20	IStateService stateService = new MockStateService();
  21	
  22	var MqttClient = new MqttFactory()
  23	  .CreateMqttClient();
  24	
  25	var cancellationTokenSource = new CancellationTokenSource();
  26	var cancellationToken = cancellationTokenSource.Token;
  27	
  28	var configuration = InitializeConfiguration();
  29	
  30	AssingHandlers();
  31	await StartMqttClientAsync(cancellationToken);
  32	WaitForStopSignal(cancellationToken);
  33	await StopMqttClientAsync(new CancellationTokenSource().Token);
  34	
  35	Configuration InitializeConfiguration()
  36	{
  37	  var configuration = GetDefaultConfiguration();
  38	
  39	  if (TryReadConfiguration(out var savedConfiguration))
  40	  {
  41	    configuration = savedConfiguration;
  42	    return configuration;
  43	  }
  44	
  45	  WriteConfiguration(configuration);
  46	  return configuration;
  47	
  48	  bool TryReadConfiguration(out Configuration configuration)
  49	  {
  50	    var currentDirectory = Directory.GetCurrentDirectory();
  51	    var pathToFile = Path.Join(currentDirectory, "configuration.json");
  52	
  53	    if (File.Exists(pathToFile))
  54	    {
  55	      var json = File.ReadAllText(pathToFile, Encoding.UTF8);
  56	      configuration = JsonConvert.DeserializeObject<Configuration>(json);
  57	      return true;
  58	    }
  59	
  60	    configuration = null;
  61	    return false;
  62	  }
  63	
  64	  Configuration GetDefaultConfiguration()
  65	  {
  66	    return new Configuration();
  67	  }
  68	
  69	  void WriteConfiguration(Configuration configuration)
  70	  {
  71	    var currentDirectory = Directory.GetCurrentDirectory();
  72	    var pathToFile = Path.Join(currentDirectory, "configuration.json");
  73	
  74	    var json = JsonConvert.SerializeObject(configuration);
  75	    File.WriteAllText(pathToFile, json, Encoding.UTF8);
  76	  }
  77	}
  78	
  79	void AssingHandlers()
  80	{
  81	  MqttClient.ConnectedAsync += HandleClientConnectedAsync;
  82	  MqttClient.ApplicationMessageReceivedAsync += HandleApplicationMessageReceivedAsync;
  83	  MqttClient.DisconnectedAsync += HandleClientDisconnectedAsync;
  84	
  85	  async Task HandleClientConnectedAsync(MqttClientConnectedEventArgs eventArgs)
  86	  {
  87	    await MqttClient.SubscribeAsync("devices/discovery", MqttQualityOfServiceLevel.AtMostOnce);
  88	    await MqttClient.SubscribeAsync($"devices/{configuration.Id}/+", MqttQualityOfServiceLevel.AtMostOnce);
  89	
  90	    Console.WriteLine("Connected to MQTT Broker.");
  91	  }
  92	
  93	  async Task HandleApplicationMessageReceivedAsync(MqttApplicationMessageReceivedEventArgs eventArgs)
  94	  {
  95	    var messageTopic = eventArgs.ApplicationMessage.Topic;
  96	    var messagePayload = Encoding.UTF8.GetString(eventArgs.ApplicationMessage.PayloadSegment);
  97	
  98	    if (messageTopic.Equals("devices/discovery") && messagePayload.Equals("start"))
  99	    {
  100	      await HandleDeviceDiscovery();
  101	    }
  102	
  103	    if (messageTopic.Equals($"devices/{configuration.Id}/changeState"))
  104	    {
  105	      Enum.TryParse(messagePayload, out State state);
  106	      await HandleChangeState(state);
  107	    }
  108	
  109	    if (messageTopic.Equals($"devices/{configuration.Id}/getStatus"))
  110	    {
  111	      if (!String.IsNullOrWhiteSpace(messagePayload))
  112	      {
  113	        return;
  114	      }
  115	
  116	      await HandleGetStatus();
  117	    }
  118	
  119	    async Task HandleDeviceDiscovery()
  120	    {
  121	      var response = new DiscoveryResponse()
  122	      {
  123	        Id = configuration.Id,
  124	        Manufacturer = configuration.Manufacturer,
  125	        SerialNumber = configuration.SerialNumber,
  126	        Name = "Generic Washing Machine"
  127	      };
  128	
  129	      var payload = JsonConvert.SerializeObject(response);
  130	
  131	      await MqttClient.PublishStringAsync(
  132	        $"devices/discovery",
  133	        payload,
  134	        MqttQualityOfServiceLevel.ExactlyOnce,
  135	        false);
  136	    }
  137	
  138	    async Task HandleChangeState(WashingMachineManagementIot.Models.State state)
  139	    {
  140	      stateService.SetState(state);
  141	    }
  142	
  143	    async Task HandleGetStatus()
  144	    {
  145	      var random = new Random();
  146	
  147	      var response = new StatusResponse()
  148	      {
  149	        State = stateService.GetState(),
  150	        WaterTemperatureCelcius = waterTemperatureService.GetWaterTemparatureInCelcius(),
  151	        MotorSpeedRpm = motorSpeedService.GetMotorSpeedInRpm(),
  152	        LoadWeightKg = loadWeightService.GetLoadWeightInKg(),
  153	        IsLidClosed = lidClosedService.GetIsLidCloed()
  154	      };
  155	
  156	      var payload = JsonConvert.SerializeObject(response);
  157	
  158	      await MqttClient.PublishStringAsync(
  159	        $"devices/{configuration.Id}/getStatus",
  160	        payload,
  161	        MqttQualityOfServiceLevel.ExactlyOnce,
  162	        false,
  163	        new CancellationTokenSource().Token);
  164	    }
  165	  }
  166	
  167	  async Task HandleClientDisconnectedAsync(MqttClientDisconnectedEventArgs eventArgs)
  168	  {
  169	    Console.WriteLine($"Lost connection with MQTT Broker. Reason: {eventArgs.Reason}. Trying to reconnect.");
  170	
  171	    _ = Task.Run(
  172	      async () =>
  173	      {
  174	        while (true)
  175	        {
  176	          try
  177	          {
  178	            if (!await MqttClient.TryPingAsync())
  179	            {
  180	              await MqttClient.ConnectAsync(MqttClient.Options);
  181	              Console.WriteLine("Reconnected to MQTT Broker.");
  182	            }
  183	          }
  184	          catch (Exception exception)
  185	          {
  186	            Console.WriteLine($"Failed connecting to MQTT Broker.\n{exception.StackTrace}");
  187	          }
  188	          finally
  189	          {
  190	            await Task.Delay(TimeSpan.FromSeconds(5));
  191	          }
  192	        }
  193	      });
  194	
  195	    await Task.CompletedTask;
  196	  }
  197	}
  198	
  199	void WaitForStopSignal(CancellationToken cancellationToken)
  200	{
  201	  Console.CancelKeyPress += async (object? sender, ConsoleCancelEventArgs e) => await StopMqttClientAsync(cancellationToken);
  202	
  203	  while (true)
  204	  {
  205	    if (!cancellationToken.IsCancellationRequested)
  206	    {
  207	      continue;
  208	    }
  209	
  210	    return;
  211	  }
  212	}
  213	
  214	async Task StartMqttClientAsync(CancellationToken cancellationToken)
  215	{
  216	  var MqttClientOptions = new MqttClientOptionsBuilder()
  217	    .WithCredentials("", "")
  218	    .WithClientId("")
  219	    .WithTcpServer(configuration.Host, configuration.Port)
  220	    .Build();
  221	
  222	  await MqttClient.ConnectAsync(MqttClientOptions);
  223	
  224	  _ = Task.Run(
  225	    async () =>
  226	    {
  227	      while (!cancellationToken.IsCancellationRequested)
  228	      {
  229	        try
  230	        {
  231	          if (!await MqttClient.TryPingAsync())
  232	          {
  233	            await MqttClient.ConnectAsync(MqttClient.Options, cancellationToken);
  234	            Console.WriteLine("The MQTT client is connected.");
  235	          }
  236	        }
  237	        catch (Exception exception)
  238	        {
  239	          Console.WriteLine($"The MQTT client connection failed.\n{exception.StackTrace}");
  240	        }
  241	        finally
  242	        {
  243	          await Task.Delay(TimeSpan.FromSeconds(5));
  244	        }
  245	      }
  246	    });
  247	}
  248	
  249	async Task StopMqttClientAsync(CancellationToken cancellationToken)
  250	{
  251	  if (cancellationToken.IsCancellationRequested)
  252	  {
  253	    var disconnectOption = new MqttClientDisconnectOptions
  254	    {
  255	      Reason = MqttClientDisconnectOptionsReason.NormalDisconnection
  256	    };
  257	
  258	    await MqttClient.DisconnectAsync(disconnectOption, cancellationToken);
  259	  }
  260	
  261	  await MqttClient.DisconnectAsync();
  262	
  263	  Console.WriteLine("Disconnected from MQTT Broker.");
  264	}


ДОДАТОК Д.
ДІАГРАМИ ВЕБ ЧАСТИНИ

Д.1 Діаграма прецедентів
Д.2 Діаграма компонентів
Д.3 Діаграма пакетів
Д.4 Діаграма взаємодії
